#### React全家桶

react、react-router、PubSub（消息管理的库），Redux（集中式状态管理）、Ant-Design（组件库）

react用于构建用户界面的JavaScipt库，

在页面展示学生信息：发送请求获取数据，处理数据，**操作DOM呈现页面**

原生JS操作DOM繁锁，效率低；会进行大量重绘重排；没有组件化；



##### React特点

1、采用**组件化**模式、**声明式编码**（相对于命令式而言，也就是what to do 和 how to do的区别，一个追求结果，一个追求过程），提高开发效率

2、在react native中可以使用react进行移动端开发、

3、使用**虚拟DOM**（放在内存里） **DIffing算法**，减少与真实DOM的交互



#### 创建虚拟DOM方式

1、利用js写

2、利用jsx（JavaScript XML）写，其实就js的语法糖

虚拟DOM本质是Objec类型的对象；虚拟DOM属性少，真实DOM多；虚拟DOM最终会被React转换为真实DOM



#### JSX语法规则

1、定义虚拟DOM时，不要用引号

2、标签中混入JS表达式时要用{}

3、样式的类名指定不要用class，要用className

4、内联样式，需要用style={{key:value}}的形式去写

5、jsx只能有一个根标签

6、标签必须闭合

7、标签首字母

​		（1）若小写字母开头，则将该标签转换为html同名元素，若html中无该标签对应的同名元素，则报错

​		（2）若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错



#### js语句(代码) js表达式

1、表达式：一个表达式会产生一个值，可以放在任意一个需要值的地方  

​		比如 a、a+b、demo(1)、arr.map()、function test(){}

2、语句（代码）if(){}、for(){}、





#### 模块与组件

1、模块：就是根据一些业务逻辑拆分成 很多js文件，向外提供特定功能的js程序

2、组件：用来实现局部功能效果的代码和资源的集合



#### 简单组件 复杂组件

复杂组件中有状态state，定义着组件的一些数据。





#### React的生命周期

生命周期回调函数（生命周期钩子函数、生命周期函数）

旧的生命周期

1、**初始化阶段** 由ReactDom.render()触发

constructor()

componentWillMount()

render()

componentDidMount() 常用，一般在这个钩子中做一些初始化的事情，开启定时器，发送网络请求，订阅消息

2、**更新阶段**  由组件内部this.setState()或父组件render触发

shouldComponentUpdate()

componentWillUpdate()

render()

componentDidUpdatet()

3、**卸载组件**

componentWillUnmount() 常用 ，做一些收尾的事情，关闭定时器，取消订阅



新的声明周期

与旧的相比 废弃了componentWillMount()、componentWillUpdate()、componentWillReceiveProps()

提出了新的钩子 getDerivedStateFromProps()、getSnapshotBeforeUpdate()



#### key的作用

虚拟DOM中key的作用

简单说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用

详细说，当状态中的数据发生变化时，react会根据新数据 生成 新的虚拟DOM

​				随后react进行 新与旧虚拟DOM的diff比较。

​				a.旧的虚拟dom找到了与新的虚拟dom相同的key

​					若虚拟DOM中内容没变，直接使用之前的真实DOM

​					若虚拟DOM中的内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM

​				b.旧虚拟DOM没找到与新虚拟DOM相同的key

​					根据数据创建新的真实DOM，随后渲染到页面



#### react脚手架配置代理总结

##### 方法一

> 在package.json中追加如下配置

```json
"proxy":"http://localhost:5000"
```

说明：

1. 优点：配置简单，前端请求资源时可以不加任何前缀。
2. 缺点：不能配置多个代理。
3. 工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）

##### 方法二

1. 第一步：创建代理配置文件

   ```
   在src下创建配置文件：src/setupProxy.js
   ```

2. 编写setupProxy.js配置具体代理规则：

   ```js
   const proxy = require('http-proxy-middleware')
   
   module.exports = function(app) {
     app.use(
       proxy('/api1', {  //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)
         target: 'http://localhost:5000', //配置转发目标地址(能返回数据的服务器地址)
         changeOrigin: true, //控制服务器接收到的请求头中host字段的值
         /*
         	changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
         	changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000
         	changeOrigin默认值为false，但我们一般将changeOrigin值设为true
         */
         pathRewrite: {'^/api1': ''} //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)
       }),
       proxy('/api2', { 
         target: 'http://localhost:5001',
         changeOrigin: true,
         pathRewrite: {'^/api2': ''}
       })
     )
   }
   ```

说明：

1. 优点：可以配置多个代理，可以灵活的控制请求是否走代理。
2. 缺点：配置繁琐，前端请求资源时必须加前缀。